<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Como funciona o encoding no protocolo HTTP?</title><meta name="description" content="my site"/><link rel="icon" href="favicon.ico"/><link rel="shortcut icon" href="favicon.ico"/><meta property="og:title" content="Como funciona o encoding no protocolo HTTP?"/><meta property="og:description" content="Ou: o que acontece com os bytes das requisições HTTP quando você se comunica com alguns servidores?"/><meta property="og:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="twitter:card" content="Ou: o que acontece com os bytes das requisições HTTP quando você se comunica com alguns servidores?"/><meta name="twitter:title" content="Como funciona o encoding no protocolo HTTP?"/><meta name="twitter:description" content="Ou: o que acontece com os bytes das requisições HTTP quando você se comunica com alguns servidores?"/><meta name="twitter:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="next-head-count" content="13"/><link rel="preload" href="/_next/static/css/19506f6b591e2b17.css" as="style"/><link rel="stylesheet" href="/_next/static/css/19506f6b591e2b17.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="data:text/javascript;base64,IWZ1bmN0aW9uKCl7dHJ5IHt2YXIgZD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dmFyIG49J2RhdGEtdGhlbWUnO3ZhciBzID0gJ3NldEF0dHJpYnV0ZSc7dmFyIGU9bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RoZW1lJyk7aWYoInN5c3RlbSI9PT1lfHwoIWUmJnRydWUpKXt2YXIgdD0iKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSIsbT13aW5kb3cubWF0Y2hNZWRpYSh0KTtpZihtLm1lZGlhIT09dHx8bS5tYXRjaGVzKXtkLnN0eWxlLmNvbG9yU2NoZW1lID0gJ2RhcmsnO2Rbc10obiwgJ2RhcmsnKX1lbHNle2Quc3R5bGUuY29sb3JTY2hlbWUgPSAnbGlnaHQnO2Rbc10obiwgJ2xpZ2h0Jyl9fWVsc2UgaWYoZSl7ZFtzXShuLCBlfHwgJycpfWlmKGU9PT0nbGlnaHQnfHxlPT09J2RhcmsnKWQuc3R5bGUuY29sb3JTY2hlbWU9ZX1jYXRjaChlKXt9fSgp" id="next-themes-script" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-5c9a0d80fa7df27e.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-ef558cc4c27e2f83.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c8af879f3541988c.js" defer=""></script><script src="/_next/static/chunks/5040-f3dafc0029c0dd85.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-08a5edc38f7a5ec4.js" defer=""></script><script src="/_next/static/4rltD73FnhizIpdTZfNZ7/_buildManifest.js" defer=""></script><script src="/_next/static/4rltD73FnhizIpdTZfNZ7/_ssgManifest.js" defer=""></script><script src="/_next/static/4rltD73FnhizIpdTZfNZ7/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col h-screen justify-between"><header><a class="text-6xl font-name font-semibold text-black-600 mt-10 flex justify-center" href="/">wrongbyte</a><div class="pages flex justify-center gap-5 mt-2 text-gray-500"><a class="false" href="/">posts</a><a class="false" href="/about">about</a><a class="false">writeups</a><a class="inline" href="https://github.com/wrongbyte">github</a><a class="inline cursor-pointer">dark<!-- --> theme</a></div><div class="py-4"><div class="w-full border-t hr border-gray-300"></div></div></header><main class="xl:w-7/12 lg:w-4/5 w-11/12 mx-auto mt-3 mb-auto"><article><h1 class="font-title text-3xl text-center mb-4">Como funciona o encoding no protocolo HTTP?</h1><p class="text-gray-500 mb-1">Thu Jan 20 2022</p><h3>Antes, um pouco de contexto...</h3>
<p>Quando temos um arquivo grande e precisamos mandá-lo para alguém, o que vem na nossa cabeça de imediato é <em>“zipar”</em> este arquivo.</p>
<p>Quando <em>zipamos</em>, isto é, comprimimos um arquivo, o que estamos fazendo na realidade ~~(de forma simplificada, é claro)~~ é aplicar um <strong>algoritmo de compressão</strong> nos seus bytes. O que esses algoritmos fazem é diminuir a redundância da sequência de bytes que compõe o arquivo, utilizando de referências como ponteiros onde ocorrem sequências que já se repetem.</p>
<h3>Mas qual a relação entre esses algoritmos e o protocolo HTTP?</h3>
<p>Imagine que você deseja fazer um GET request para um site, por exemplo para http://example.org.
No seu browser, você vai ver a seguinte página, interpretada pelo seu browser:
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gt3t8q20lvryghcx62m8.png" alt="Site normal"/></p>
<p>Contudo, o que você de fato recebe do servidor é uma <strong>enorme stream contendo o código-fonte da página</strong>, após as headers:
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wtq2n6c7nngf6taw83ho.png" alt="Código fonte do site"/></p>
<p>Logo transferir o conteúdo de páginas contendo uma quantidade extensa de dados torna-se pouco efetivo, tanto para o cliente quanto para o servidor. <strong>A partir disso, podemos então &quot;zipar&quot; a resposta que recebemos. Ao fazer isso, diminuímos o tamanho da resposta, que vem comprimida, e assim aumentamos a eficiência da comunicação.</strong></p>
<h3>Como isso ocorre?</h3>
<p>Normalmente, a resposta é comprimida utilizando-se do algoritmo <strong>gzip</strong>, mas isso vai depender do servidor.
Antes da aplicação efetiva do algoritmo de compressão, ocorre a chamada &quot;negociação&quot; entre o browser e o servidor: <strong>o browser envia a header <span class="code">accept-encoding</span></strong> com o algoritmo suportado (exemplo: <span class="code">Accept-Encoding: gzip</span>) e <strong>o server responde com a header <span class="code">content-encoding</span></strong> com o algoritmo escolhido.
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/b3zumzo1mutvmyh6z7sp.png" alt="Negociação HTTTP"/>
Obs: nesse caso, usamos a header <span class="code">Vary</span> para armazenar em cache os diferentes valores para o encoding.</p>
<p>Dessa forma, as headers <span class="code">Accept-Encoding</span> e <span class="code">Content-Encoding</span> vão definir o algoritmo de compressão escolhido para diminuir o tamanho dos arquivos sendo transferidos na comunicação. Isso é de extrema importância para tornar o uso da conexão mais eficiente.</p>
<h3>Mas é possível otimizar ainda mais a comunicação através do uso de outra header: <span class="code">Transfer-Encoding</span></h3>
<p>Quando recebemos a resposta do servidor, recebemos o que é chamado de &quot;payload&quot;. Isso é a resposta que pode ser, como já vimos acima, uma página HTML por exemplo.
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x2yrsfwc86m5l6aauyqz.png" alt="payload"/></p>
<blockquote>
<p><em>Definition of payload : The &quot;actual data&quot; in a packet or file minus all headers attached for transport and minus all descriptive meta-data. In a network packet, headers are appended to the payload for transport and then discarded at their destination.</em></p>
</blockquote>
<p><strong>Contudo, é possível &quot;dividir&quot; esse payload, e isso ocorre quando utilizamos da header <span class="code">transfer-encoding</span>.</strong> Quando essa header não é utilizada, o payload body e message body são iguais.</p>
<p>Exemplo da resposta vista antes, porém com transfer-encoding:
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bl300b8gih3mv37xjilu.png" alt="chunked response"/></p>
<p>Ou seja, as respostas com transfer-encoding seguem a seguinte estrutura:
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7pc1mu71szfb49yb5q9i.png" alt="estrutura"/>
Isso divide as informações recebidas em <strong>chunks</strong>, ou seja, &quot;pedaços&quot; de dados. Isso, além de ajudar a diminuir a carga da comunicação, ajuda o servidor a manter uma conexão mesmo para conteúdos gerados dinamicamente.
Em muitos servidores, é comum ocorrer a combinação de Content-Encoding: gzip + Transfer-Encoding: chunked, por tornarem a comunicação mais eficiente.</p></article><div class="py-4"><div class="w-full border-t hr border-gray-300 mt-3"></div></div></main><footer class=" flex justify-center"><span class="mb-3">• wrongbyte © • 2022 •</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Como funciona o encoding no protocolo HTTP?","description":"Ou: o que acontece com os bytes das requisições HTTP quando você se comunica com alguns servidores?","date":"Thu Jan 20 2022","content":"\n### Antes, um pouco de contexto...\nQuando temos um arquivo grande e precisamos mandá-lo para alguém, o que vem na nossa cabeça de imediato é _“zipar”_ este arquivo.\n\nQuando _zipamos_, isto é, comprimimos um arquivo, o que estamos fazendo na realidade ~~(de forma simplificada, é claro)~~ é aplicar um **algoritmo de compressão** nos seus bytes. O que esses algoritmos fazem é diminuir a redundância da sequência de bytes que compõe o arquivo, utilizando de referências como ponteiros onde ocorrem sequências que já se repetem. \n\n\n### Mas qual a relação entre esses algoritmos e o protocolo HTTP?\nImagine que você deseja fazer um GET request para um site, por exemplo para http://example.org.\nNo seu browser, você vai ver a seguinte página, interpretada pelo seu browser:\n![Site normal](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gt3t8q20lvryghcx62m8.png)\n \nContudo, o que você de fato recebe do servidor é uma **enorme stream contendo o código-fonte da página**, após as headers:\n![Código fonte do site](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wtq2n6c7nngf6taw83ho.png)\n\nLogo transferir o conteúdo de páginas contendo uma quantidade extensa de dados torna-se pouco efetivo, tanto para o cliente quanto para o servidor. **A partir disso, podemos então \"zipar\" a resposta que recebemos. Ao fazer isso, diminuímos o tamanho da resposta, que vem comprimida, e assim aumentamos a eficiência da comunicação.**\n\n\n\n### Como isso ocorre?\nNormalmente, a resposta é comprimida utilizando-se do algoritmo **gzip**, mas isso vai depender do servidor. \nAntes da aplicação efetiva do algoritmo de compressão, ocorre a chamada \"negociação\" entre o browser e o servidor: **o browser envia a header `accept-encoding`** com o algoritmo suportado (exemplo: `Accept-Encoding: gzip`) e **o server responde com a header `content-encoding`** com o algoritmo escolhido.\n![Negociação HTTTP](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/b3zumzo1mutvmyh6z7sp.png)\nObs: nesse caso, usamos a header `Vary` para armazenar em cache os diferentes valores para o encoding.\n\nDessa forma, as headers `Accept-Encoding` e `Content-Encoding` vão definir o algoritmo de compressão escolhido para diminuir o tamanho dos arquivos sendo transferidos na comunicação. Isso é de extrema importância para tornar o uso da conexão mais eficiente.\n\n\n### Mas é possível otimizar ainda mais a comunicação através do uso de outra header: `Transfer-Encoding` \nQuando recebemos a resposta do servidor, recebemos o que é chamado de \"payload\". Isso é a resposta que pode ser, como já vimos acima, uma página HTML por exemplo.\n![payload](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x2yrsfwc86m5l6aauyqz.png)\n\n\u003e _Definition of payload : The \"actual data\" in a packet or file minus all headers attached for transport and minus all descriptive meta-data. In a network packet, headers are appended to the payload for transport and then discarded at their destination._\n\n**Contudo, é possível \"dividir\" esse payload, e isso ocorre quando utilizamos da header `transfer-encoding`.** Quando essa header não é utilizada, o payload body e message body são iguais.\n \nExemplo da resposta vista antes, porém com transfer-encoding:\n![chunked response](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bl300b8gih3mv37xjilu.png)\n\nOu seja, as respostas com transfer-encoding seguem a seguinte estrutura:\n![estrutura](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7pc1mu71szfb49yb5q9i.png)\nIsso divide as informações recebidas em **chunks**, ou seja, \"pedaços\" de dados. Isso, além de ajudar a diminuir a carga da comunicação, ajuda o servidor a manter uma conexão mesmo para conteúdos gerados dinamicamente.\nEm muitos servidores, é comum ocorrer a combinação de Content-Encoding: gzip + Transfer-Encoding: chunked, por tornarem a comunicação mais eficiente.\n ","slug":"httpencoding","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h3: \"h3\",\n      p: \"p\",\n      em: \"em\",\n      strong: \"strong\",\n      img: \"img\",\n      code: \"code\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h3, {\n        children: \"Antes, um pouco de contexto...\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Quando temos um arquivo grande e precisamos mandá-lo para alguém, o que vem na nossa cabeça de imediato é \", _jsx(_components.em, {\n          children: \"“zipar”\"\n        }), \" este arquivo.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Quando \", _jsx(_components.em, {\n          children: \"zipamos\"\n        }), \", isto é, comprimimos um arquivo, o que estamos fazendo na realidade ~~(de forma simplificada, é claro)~~ é aplicar um \", _jsx(_components.strong, {\n          children: \"algoritmo de compressão\"\n        }), \" nos seus bytes. O que esses algoritmos fazem é diminuir a redundância da sequência de bytes que compõe o arquivo, utilizando de referências como ponteiros onde ocorrem sequências que já se repetem.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Mas qual a relação entre esses algoritmos e o protocolo HTTP?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Imagine que você deseja fazer um GET request para um site, por exemplo para http://example.org.\\nNo seu browser, você vai ver a seguinte página, interpretada pelo seu browser:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gt3t8q20lvryghcx62m8.png\",\n          alt: \"Site normal\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Contudo, o que você de fato recebe do servidor é uma \", _jsx(_components.strong, {\n          children: \"enorme stream contendo o código-fonte da página\"\n        }), \", após as headers:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wtq2n6c7nngf6taw83ho.png\",\n          alt: \"Código fonte do site\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Logo transferir o conteúdo de páginas contendo uma quantidade extensa de dados torna-se pouco efetivo, tanto para o cliente quanto para o servidor. \", _jsx(_components.strong, {\n          children: \"A partir disso, podemos então \\\"zipar\\\" a resposta que recebemos. Ao fazer isso, diminuímos o tamanho da resposta, que vem comprimida, e assim aumentamos a eficiência da comunicação.\"\n        })]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Como isso ocorre?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Normalmente, a resposta é comprimida utilizando-se do algoritmo \", _jsx(_components.strong, {\n          children: \"gzip\"\n        }), \", mas isso vai depender do servidor.\\nAntes da aplicação efetiva do algoritmo de compressão, ocorre a chamada \\\"negociação\\\" entre o browser e o servidor: \", _jsxs(_components.strong, {\n          children: [\"o browser envia a header \", _jsx(_components.code, {\n            children: \"accept-encoding\"\n          })]\n        }), \" com o algoritmo suportado (exemplo: \", _jsx(_components.code, {\n          children: \"Accept-Encoding: gzip\"\n        }), \") e \", _jsxs(_components.strong, {\n          children: [\"o server responde com a header \", _jsx(_components.code, {\n            children: \"content-encoding\"\n          })]\n        }), \" com o algoritmo escolhido.\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/b3zumzo1mutvmyh6z7sp.png\",\n          alt: \"Negociação HTTTP\"\n        }), \"\\nObs: nesse caso, usamos a header \", _jsx(_components.code, {\n          children: \"Vary\"\n        }), \" para armazenar em cache os diferentes valores para o encoding.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Dessa forma, as headers \", _jsx(_components.code, {\n          children: \"Accept-Encoding\"\n        }), \" e \", _jsx(_components.code, {\n          children: \"Content-Encoding\"\n        }), \" vão definir o algoritmo de compressão escolhido para diminuir o tamanho dos arquivos sendo transferidos na comunicação. Isso é de extrema importância para tornar o uso da conexão mais eficiente.\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"Mas é possível otimizar ainda mais a comunicação através do uso de outra header: \", _jsx(_components.code, {\n          children: \"Transfer-Encoding\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Quando recebemos a resposta do servidor, recebemos o que é chamado de \\\"payload\\\". Isso é a resposta que pode ser, como já vimos acima, uma página HTML por exemplo.\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x2yrsfwc86m5l6aauyqz.png\",\n          alt: \"payload\"\n        })]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.em, {\n            children: \"Definition of payload : The \\\"actual data\\\" in a packet or file minus all headers attached for transport and minus all descriptive meta-data. In a network packet, headers are appended to the payload for transport and then discarded at their destination.\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsxs(_components.strong, {\n          children: [\"Contudo, é possível \\\"dividir\\\" esse payload, e isso ocorre quando utilizamos da header \", _jsx(_components.code, {\n            children: \"transfer-encoding\"\n          }), \".\"]\n        }), \" Quando essa header não é utilizada, o payload body e message body são iguais.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Exemplo da resposta vista antes, porém com transfer-encoding:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bl300b8gih3mv37xjilu.png\",\n          alt: \"chunked response\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Ou seja, as respostas com transfer-encoding seguem a seguinte estrutura:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7pc1mu71szfb49yb5q9i.png\",\n          alt: \"estrutura\"\n        }), \"\\nIsso divide as informações recebidas em \", _jsx(_components.strong, {\n          children: \"chunks\"\n        }), \", ou seja, \\\"pedaços\\\" de dados. Isso, além de ajudar a diminuir a carga da comunicação, ajuda o servidor a manter uma conexão mesmo para conteúdos gerados dinamicamente.\\nEm muitos servidores, é comum ocorrer a combinação de Content-Encoding: gzip + Transfer-Encoding: chunked, por tornarem a comunicação mais eficiente.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"httpencoding"},"buildId":"4rltD73FnhizIpdTZfNZ7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>