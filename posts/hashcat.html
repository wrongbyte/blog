<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Cracking a hashed password with hashcat</title><meta name="description" content="my site"/><link rel="icon" href="favicon.ico"/><link rel="shortcut icon" href="favicon.ico"/><meta property="og:type" content="website"/><meta property="og:title" content="Cracking a hashed password with hashcat"/><meta property="og:description" content="... through a simple example of how this process works"/><meta property="og:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="twitter:card" content="... through a simple example of how this process works"/><meta name="twitter:title" content="Cracking a hashed password with hashcat"/><meta name="twitter:description" content="... through a simple example of how this process works"/><meta name="twitter:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/ad5d283186ee739e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ad5d283186ee739e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="data:text/javascript;base64,IWZ1bmN0aW9uKCl7dHJ5IHt2YXIgZD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dmFyIG49J2RhdGEtdGhlbWUnO3ZhciBzID0gJ3NldEF0dHJpYnV0ZSc7dmFyIGU9bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RoZW1lJyk7aWYoInN5c3RlbSI9PT1lfHwoIWUmJnRydWUpKXt2YXIgdD0iKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSIsbT13aW5kb3cubWF0Y2hNZWRpYSh0KTtpZihtLm1lZGlhIT09dHx8bS5tYXRjaGVzKXtkLnN0eWxlLmNvbG9yU2NoZW1lID0gJ2RhcmsnO2Rbc10obiwgJ2RhcmsnKX1lbHNle2Quc3R5bGUuY29sb3JTY2hlbWUgPSAnbGlnaHQnO2Rbc10obiwgJ2xpZ2h0Jyl9fWVsc2UgaWYoZSl7ZFtzXShuLCBlfHwgJycpfWlmKGU9PT0nbGlnaHQnfHxlPT09J2RhcmsnKWQuc3R5bGUuY29sb3JTY2hlbWU9ZX1jYXRjaChlKXt9fSgp" id="next-themes-script" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-d40c6b954e8c779e.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-ef558cc4c27e2f83.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c8af879f3541988c.js" defer=""></script><script src="/_next/static/chunks/5040-f3dafc0029c0dd85.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-a086c8fcdc0e2330.js" defer=""></script><script src="/_next/static/OcaEdg7dR05c36hw1ReRZ/_buildManifest.js" defer=""></script><script src="/_next/static/OcaEdg7dR05c36hw1ReRZ/_ssgManifest.js" defer=""></script><script src="/_next/static/OcaEdg7dR05c36hw1ReRZ/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col h-screen justify-between"><header><a class="text-6xl font-name font-semibold text-black-600 mt-10 flex justify-center" href="/">wrongbyte</a><div class="pages flex justify-center gap-5 mt-2 text-gray-500"><a class="false" href="/">posts</a><a class="false" href="/about">about</a><a class="false">writeups</a><a class="inline" href="https://github.com/wrongbyte">github</a><a class="inline cursor-pointer">dark<!-- --> theme</a></div><div class="py-4"><div class="w-full border-t hr border-gray-300"></div></div></header><main class="xl:w-7/12 lg:w-4/5 w-11/12 mx-auto mt-3 mb-auto"><article><h1 class="font-title text-3xl text-center mb-4">Cracking a hashed password with hashcat</h1><p class="text-gray-500 mb-1">Thu Jun 16 2022</p><p>Given a hashed password <span class="code">$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom</span>, we have only one hint: <strong>the password has four letters, all lowercase.</strong></p>
<h3>Let&#x27;s start: finding the hash type</h3>
<p>There are <strong>a lot</strong> of hashes out there. A good way to start guessing is to look at the hashed pass and try to find some kind of pattern. Here, the key is the first 4 characters of the hash.
There is a page where you can look at example hashes: https://hashcat.net/wiki/doku.php?id=example_hashes
<strong>Noticed something?</strong> We are looking for the <em>bcrypt $2*$, Blowfish (Unix)</em>. Our <span class="code">$2y$</span> matches this pattern. So we are looking for a bcrypt hash. We also can grasp that the hash was generated using a factor of 12 (it is the number that comes after the first four characters).</p>
<h3>Let&#x27;s crack!</h3>
<p>First, it is important to know how the process works. Hashing is a process essentially different from encryption - you can only do it once. It means that we cannot <em>really</em> recover the plaintext of a hashed password; instead, we can only compare its hash with our guesses. So, it&#x27;s like hashing several words and seeing which of them matches exaclty our hash. Then, it must be the password.
We can automatize this process with two tools: <span class="code">hashcat</span> and a dictionary of potential passwords. This kind of dictionary is easy to find on internet, so we are going to use <a class="article-link" href="https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt">rock you</a>.</p>
<p>Ok, so our dictionary is <em>very large</em> and checking for each password, one by one, would be an expensive operation. But we already know how our password looks like, right? (four letters, all lowercase).
So, let&#x27;s filter our dictionary a little bit by creating a file containing all the passwords that match our condition:</p>
<p><span class="code">grep -x -E &#x27;[a-z][^0-9]{4}&#x27; rockyou.txt &gt; candidates.txt</span></p>
<p>Here we are using <span class="code">grep</span> along with a regex expression to filter our potential passwords to only four-letters words without digits. The -x flag applies this expression to the whole line (our file contains one password per line), whereas the -E flag is needed because we are using an extended expression (due to the <span class="code">{4}</span> part).</p>
<p>Now, we are ready to crack it with hashcat:</p>
<p><span class="code">hashcat -a 0 -m 3200 pass.txt candidates.txt --force</span></p>
<p>Here, the code 3200 stands for the <span class="code">bcrypt</span> hash, and our hashed pass is stored in pass.txt whereas the potential passwords are stored in candidates.txt.</p>
<p>After a few seconds (depending on your computer), we have the result:
<span class="code">$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom:bleh</span></p>
<p>Where the &quot;bleh&quot; is the password we were looking for.</p>
<p>~~<em>In sum: use a password manager :)</em>~~</p></article><div class="py-4"><div class="w-full border-t hr border-gray-300 mt-3"></div></div></main><footer class=" flex justify-center"><span class="mb-3">• wrongbyte © • 2022 •</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Cracking a hashed password with hashcat","description":"... through a simple example of how this process works","date":"Thu Jun 16 2022","content":"\nGiven a hashed password `$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom`, we have only one hint: **the password has four letters, all lowercase.**\n\n### Let's start: finding the hash type\nThere are **a lot** of hashes out there. A good way to start guessing is to look at the hashed pass and try to find some kind of pattern. Here, the key is the first 4 characters of the hash.\nThere is a page where you can look at example hashes: https://hashcat.net/wiki/doku.php?id=example_hashes\n**Noticed something?** We are looking for the _bcrypt $2*$, Blowfish (Unix)_. Our `$2y$` matches this pattern. So we are looking for a bcrypt hash. We also can grasp that the hash was generated using a factor of 12 (it is the number that comes after the first four characters).\n\n### Let's crack!\nFirst, it is important to know how the process works. Hashing is a process essentially different from encryption - you can only do it once. It means that we cannot _really_ recover the plaintext of a hashed password; instead, we can only compare its hash with our guesses. So, it's like hashing several words and seeing which of them matches exaclty our hash. Then, it must be the password.\nWe can automatize this process with two tools: `hashcat` and a dictionary of potential passwords. This kind of dictionary is easy to find on internet, so we are going to use [rock you](https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt).\n\nOk, so our dictionary is _very large_ and checking for each password, one by one, would be an expensive operation. But we already know how our password looks like, right? (four letters, all lowercase).\nSo, let's filter our dictionary a little bit by creating a file containing all the passwords that match our condition: \n\n`grep -x -E '[a-z][^0-9]{4}' rockyou.txt \u003e candidates.txt`\n\nHere we are using `grep` along with a regex expression to filter our potential passwords to only four-letters words without digits. The -x flag applies this expression to the whole line (our file contains one password per line), whereas the -E flag is needed because we are using an extended expression (due to the `{4}` part).\n\nNow, we are ready to crack it with hashcat:\n\n`hashcat -a 0 -m 3200 pass.txt candidates.txt --force`\n\nHere, the code 3200 stands for the `bcrypt` hash, and our hashed pass is stored in pass.txt whereas the potential passwords are stored in candidates.txt.\n\nAfter a few seconds (depending on your computer), we have the result:\n`$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom:bleh`\n\nWhere the \"bleh\" is the password we were looking for.\n\n~~_In sum: use a password manager :)_~~\n","slug":"hashcat","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      strong: \"strong\",\n      h3: \"h3\",\n      em: \"em\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"Given a hashed password \", _jsx(_components.code, {\n          children: \"$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom\"\n        }), \", we have only one hint: \", _jsx(_components.strong, {\n          children: \"the password has four letters, all lowercase.\"\n        })]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Let's start: finding the hash type\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"There are \", _jsx(_components.strong, {\n          children: \"a lot\"\n        }), \" of hashes out there. A good way to start guessing is to look at the hashed pass and try to find some kind of pattern. Here, the key is the first 4 characters of the hash.\\nThere is a page where you can look at example hashes: https://hashcat.net/wiki/doku.php?id=example_hashes\\n\", _jsx(_components.strong, {\n          children: \"Noticed something?\"\n        }), \" We are looking for the \", _jsx(_components.em, {\n          children: \"bcrypt $2*$, Blowfish (Unix)\"\n        }), \". Our \", _jsx(_components.code, {\n          children: \"$2y$\"\n        }), \" matches this pattern. So we are looking for a bcrypt hash. We also can grasp that the hash was generated using a factor of 12 (it is the number that comes after the first four characters).\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Let's crack!\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"First, it is important to know how the process works. Hashing is a process essentially different from encryption - you can only do it once. It means that we cannot \", _jsx(_components.em, {\n          children: \"really\"\n        }), \" recover the plaintext of a hashed password; instead, we can only compare its hash with our guesses. So, it's like hashing several words and seeing which of them matches exaclty our hash. Then, it must be the password.\\nWe can automatize this process with two tools: \", _jsx(_components.code, {\n          children: \"hashcat\"\n        }), \" and a dictionary of potential passwords. This kind of dictionary is easy to find on internet, so we are going to use \", _jsx(_components.a, {\n          href: \"https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt\",\n          children: \"rock you\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Ok, so our dictionary is \", _jsx(_components.em, {\n          children: \"very large\"\n        }), \" and checking for each password, one by one, would be an expensive operation. But we already know how our password looks like, right? (four letters, all lowercase).\\nSo, let's filter our dictionary a little bit by creating a file containing all the passwords that match our condition:\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"grep -x -E '[a-z][^0-9]{4}' rockyou.txt \u003e candidates.txt\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Here we are using \", _jsx(_components.code, {\n          children: \"grep\"\n        }), \" along with a regex expression to filter our potential passwords to only four-letters words without digits. The -x flag applies this expression to the whole line (our file contains one password per line), whereas the -E flag is needed because we are using an extended expression (due to the \", _jsx(_components.code, {\n          children: \"{4}\"\n        }), \" part).\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now, we are ready to crack it with hashcat:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"hashcat -a 0 -m 3200 pass.txt candidates.txt --force\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Here, the code 3200 stands for the \", _jsx(_components.code, {\n          children: \"bcrypt\"\n        }), \" hash, and our hashed pass is stored in pass.txt whereas the potential passwords are stored in candidates.txt.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"After a few seconds (depending on your computer), we have the result:\\n\", _jsx(_components.code, {\n          children: \"$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom:bleh\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Where the \\\"bleh\\\" is the password we were looking for.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"~~\", _jsx(_components.em, {\n          children: \"In sum: use a password manager :)\"\n        }), \"~~\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"hashcat"},"buildId":"OcaEdg7dR05c36hw1ReRZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>