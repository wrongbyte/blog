<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Como funciona a codificação em base64?</title><meta name="description" content="my site"/><link rel="icon" href="favicon.ico"/><link rel="shortcut icon" href="favicon.ico"/><meta property="og:title" content="Como funciona a codificação em base64?"/><meta property="og:description" content="Entendendo o significado de letras e números aparentemente aleatórios"/><meta property="og:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="twitter:card" content="Entendendo o significado de letras e números aparentemente aleatórios"/><meta name="twitter:title" content="Como funciona a codificação em base64?"/><meta name="twitter:description" content="Entendendo o significado de letras e números aparentemente aleatórios"/><meta name="twitter:image" content="https://pbs.twimg.com/media/FMfaMdVUYAAtgp2?format=jpg&amp;name=large"/><meta name="next-head-count" content="13"/><link rel="preload" href="/_next/static/css/19506f6b591e2b17.css" as="style"/><link rel="stylesheet" href="/_next/static/css/19506f6b591e2b17.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="data:text/javascript;base64,IWZ1bmN0aW9uKCl7dHJ5IHt2YXIgZD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dmFyIG49J2RhdGEtdGhlbWUnO3ZhciBzID0gJ3NldEF0dHJpYnV0ZSc7dmFyIGU9bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RoZW1lJyk7aWYoInN5c3RlbSI9PT1lfHwoIWUmJnRydWUpKXt2YXIgdD0iKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSIsbT13aW5kb3cubWF0Y2hNZWRpYSh0KTtpZihtLm1lZGlhIT09dHx8bS5tYXRjaGVzKXtkLnN0eWxlLmNvbG9yU2NoZW1lID0gJ2RhcmsnO2Rbc10obiwgJ2RhcmsnKX1lbHNle2Quc3R5bGUuY29sb3JTY2hlbWUgPSAnbGlnaHQnO2Rbc10obiwgJ2xpZ2h0Jyl9fWVsc2UgaWYoZSl7ZFtzXShuLCBlfHwgJycpfWlmKGU9PT0nbGlnaHQnfHxlPT09J2RhcmsnKWQuc3R5bGUuY29sb3JTY2hlbWU9ZX1jYXRjaChlKXt9fSgp" id="next-themes-script" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-5c9a0d80fa7df27e.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-ef558cc4c27e2f83.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c8af879f3541988c.js" defer=""></script><script src="/_next/static/chunks/5040-f3dafc0029c0dd85.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-08a5edc38f7a5ec4.js" defer=""></script><script src="/_next/static/ecsgcraKaXzPxBFC2Ur8N/_buildManifest.js" defer=""></script><script src="/_next/static/ecsgcraKaXzPxBFC2Ur8N/_ssgManifest.js" defer=""></script><script src="/_next/static/ecsgcraKaXzPxBFC2Ur8N/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col h-screen justify-between"><header><a class="text-6xl font-name font-semibold text-black-600 mt-10 flex justify-center" href="/">wrongbyte</a><div class="pages flex justify-center gap-5 mt-2 text-gray-500"><a class="false" href="/">posts</a><a class="false" href="/about">about</a><a class="false">writeups</a><a class="inline" href="https://github.com/wrongbyte">github</a><a class="inline cursor-pointer">dark<!-- --> theme</a></div><div class="py-4"><div class="w-full border-t hr border-gray-300"></div></div></header><main class="xl:w-7/12 lg:w-4/5 w-11/12 mx-auto mt-3 mb-auto"><article><h1 class="font-title text-3xl text-center mb-4">Como funciona a codificação em base64?</h1><p class="text-gray-500 mb-1">Wed Feb 23 2022</p><p>Quando falamos de texto - ou, mais precisamente, as letras que compõem o alfabeto - estamos falando de caracteres individuais que são representados da mesma forma que números, quando lidos pelo computador. Isto é, tanto letras e números são convertidos para <strong>valores binários</strong>.</p>
<p>Veja a tabela abaixo:
<img src="https://s2.glbimg.com/fEu3dqWDHAo0Gi1rGJin--DMiT4=/695x0/s.glbimg.com/po/tt2/f/original/2015/02/12/imagem28.jpg" alt="tabela ascii"/></p>
<p>Cada letra possui um índice na chamada tabela ASCII. Isso significa que podemos representar letras através de números.
Logo, a palavra &quot;Man&quot; seria representada pelos valores 77, 97 e 110.
Esses valores, por sua vez, convertidos para base binária, correspondem a <span class="code">01001101</span> <span class="code">01100001</span> <span class="code">01101110</span>.
Até aqui, nenhuma informação muito nova.</p>
<p>Contudo, o que acontece se quisermos codificar dados binários e transmiti-los através de locais que são designados para lidar com dados em texto (caracteres alfanuméricos)?
A forma escolhida para fazer isso de maneira otimizada é <strong>codificar os dados na base64</strong>.</p>
<h3>O que é base64?</h3>
<p>Imagine que você quer inserir uma imagem em uma página web. Temos então um típico caso no qual a conversão para base64 é útil: páginas HTML são otimizadas para texto, e portanto converter as informações binárias para texto se torna interessante.</p>
<h3>Como funciona a codificação?</h3>
<p>Para simplificar, vamos utilizar o exemplo anterior.
A palavra &quot;Man&quot; é representada por 3 bytes, <span class="code">01001101</span> <span class="code">01100001</span> <span class="code">01101110</span>.
Cada byte possui 8 bits, porém para iniciar a codificação para base64, precisamos que cada caractere corresponda a 6 bits. <em>(Detalhe: 2^6 é igual a 64, o número total de valores possíveis em base64, portanto o nome da codificação)</em>
Isso é feito juntando os 3 números, obtendo uma string de 24 bits: <span class="code">010011010110000101101110</span>.
Dividindo a string de 24 bits em 4 dígitos de 6 bits cada, temos agora:
<span class="code">010011</span> <span class="code">010110</span> <span class="code">000101</span> <span class="code">101110</span>, que correspondem, em decimal, a <span class="code">19</span>,<span class="code">22</span>,<span class="code">5</span> e <span class="code">46</span>.</p>
<p>O próximo passo é encontrar a correspondência de cada dígito na tabela base64:
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5i8q51ad7u1zer65zljs.png" alt="tabela base64"/></p>
<p>Finalmente, isso nos dá <span class="code">TWFu</span> como resultado. A codificação está feita. :tada:</p>
<h4>A divisão em 24 bits e padding</h4>
<p>Sabendo que a conversão para base64 se dá em grupos de 24 bits, ou de 4 dígitos com 6 bits, chegamos a uma questão importante: <strong>o que ocorre caso não tenhamos os 4 dígitos completos?</strong>
Vamos supor que em vez de &quot;Man&quot;, tenhamos &quot;Ma&quot;. Isso resultaria em dois bytes, ou 16 bits no total.
O próximo múltiplo de 6 é 18, logo, para que possamos ter 3 dígitos de 6 bits, precisamos adicionar 2 bits na string representada.
Isso significa que <span class="code">0100110101100001</span> se torna <span class="code">010011010110000100</span>, porque adicionamos 2 bits - dois zeros - no final, o que é chamado de <em>padding</em>. Assim, podemos então dividir essa string em 3 dígitos de 6 bits e adicionar um quarto bit para completar o quarteto. Esse bit é o padding que, na hora da conversão para ASCII, vai ser representado por <span class="code">=</span>. Então Ma corresponde agora a <span class="code">TWE=</span>.
Veja, no exemplo abaixo, alguns casos onde o padding é adicionado:
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ayqxq04qgkve5wcq7xzi.png" alt="padding examples"/></p>
<p>É importante notar que nem sempre o padding vai ser obrigatório, já que é possível saber se há bits que faltam pelo tamanho da string codificada - já que esse número deve ser sempre múltiplo de 4.</p></article><div class="py-4"><div class="w-full border-t hr border-gray-300 mt-3"></div></div></main><footer class=" flex justify-center"><span class="mb-3">• wrongbyte © • 2022 •</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Como funciona a codificação em base64?","description":"Entendendo o significado de letras e números aparentemente aleatórios","date":"Wed Feb 23 2022","content":"\nQuando falamos de texto - ou, mais precisamente, as letras que compõem o alfabeto - estamos falando de caracteres individuais que são representados da mesma forma que números, quando lidos pelo computador. Isto é, tanto letras e números são convertidos para **valores binários**.\n\nVeja a tabela abaixo:\n![tabela ascii](https://s2.glbimg.com/fEu3dqWDHAo0Gi1rGJin--DMiT4=/695x0/s.glbimg.com/po/tt2/f/original/2015/02/12/imagem28.jpg)\n\nCada letra possui um índice na chamada tabela ASCII. Isso significa que podemos representar letras através de números.\nLogo, a palavra \"Man\" seria representada pelos valores 77, 97 e 110. \nEsses valores, por sua vez, convertidos para base binária, correspondem a `01001101` `01100001` `01101110`.\nAté aqui, nenhuma informação muito nova. \n\nContudo, o que acontece se quisermos codificar dados binários e transmiti-los através de locais que são designados para lidar com dados em texto (caracteres alfanuméricos)? \nA forma escolhida para fazer isso de maneira otimizada é **codificar os dados na base64**.\n\n### O que é base64?\nImagine que você quer inserir uma imagem em uma página web. Temos então um típico caso no qual a conversão para base64 é útil: páginas HTML são otimizadas para texto, e portanto converter as informações binárias para texto se torna interessante.\n\n### Como funciona a codificação?\nPara simplificar, vamos utilizar o exemplo anterior.\nA palavra \"Man\" é representada por 3 bytes, `01001101` `01100001` `01101110`. \nCada byte possui 8 bits, porém para iniciar a codificação para base64, precisamos que cada caractere corresponda a 6 bits. _(Detalhe: 2^6 é igual a 64, o número total de valores possíveis em base64, portanto o nome da codificação)_\nIsso é feito juntando os 3 números, obtendo uma string de 24 bits: `010011010110000101101110`.\nDividindo a string de 24 bits em 4 dígitos de 6 bits cada, temos agora:\n`010011` `010110` `000101` `101110`, que correspondem, em decimal, a `19`,`22`,`5` e `46`.\n\nO próximo passo é encontrar a correspondência de cada dígito na tabela base64:\n![tabela base64](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5i8q51ad7u1zer65zljs.png)\n\nFinalmente, isso nos dá `TWFu` como resultado. A codificação está feita. :tada:\n\n\n#### A divisão em 24 bits e padding\nSabendo que a conversão para base64 se dá em grupos de 24 bits, ou de 4 dígitos com 6 bits, chegamos a uma questão importante: **o que ocorre caso não tenhamos os 4 dígitos completos?**\nVamos supor que em vez de \"Man\", tenhamos \"Ma\". Isso resultaria em dois bytes, ou 16 bits no total.\nO próximo múltiplo de 6 é 18, logo, para que possamos ter 3 dígitos de 6 bits, precisamos adicionar 2 bits na string representada.\nIsso significa que `0100110101100001` se torna `010011010110000100`, porque adicionamos 2 bits - dois zeros - no final, o que é chamado de _padding_. Assim, podemos então dividir essa string em 3 dígitos de 6 bits e adicionar um quarto bit para completar o quarteto. Esse bit é o padding que, na hora da conversão para ASCII, vai ser representado por `=`. Então Ma corresponde agora a `TWE=`.\nVeja, no exemplo abaixo, alguns casos onde o padding é adicionado:\n![padding examples](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ayqxq04qgkve5wcq7xzi.png)\n \nÉ importante notar que nem sempre o padding vai ser obrigatório, já que é possível saber se há bits que faltam pelo tamanho da string codificada - já que esse número deve ser sempre múltiplo de 4.","slug":"base64","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      strong: \"strong\",\n      img: \"img\",\n      code: \"code\",\n      h3: \"h3\",\n      em: \"em\",\n      h4: \"h4\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"Quando falamos de texto - ou, mais precisamente, as letras que compõem o alfabeto - estamos falando de caracteres individuais que são representados da mesma forma que números, quando lidos pelo computador. Isto é, tanto letras e números são convertidos para \", _jsx(_components.strong, {\n          children: \"valores binários\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Veja a tabela abaixo:\\n\", _jsx(_components.img, {\n          src: \"https://s2.glbimg.com/fEu3dqWDHAo0Gi1rGJin--DMiT4=/695x0/s.glbimg.com/po/tt2/f/original/2015/02/12/imagem28.jpg\",\n          alt: \"tabela ascii\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Cada letra possui um índice na chamada tabela ASCII. Isso significa que podemos representar letras através de números.\\nLogo, a palavra \\\"Man\\\" seria representada pelos valores 77, 97 e 110.\\nEsses valores, por sua vez, convertidos para base binária, correspondem a \", _jsx(_components.code, {\n          children: \"01001101\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01100001\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01101110\"\n        }), \".\\nAté aqui, nenhuma informação muito nova.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Contudo, o que acontece se quisermos codificar dados binários e transmiti-los através de locais que são designados para lidar com dados em texto (caracteres alfanuméricos)?\\nA forma escolhida para fazer isso de maneira otimizada é \", _jsx(_components.strong, {\n          children: \"codificar os dados na base64\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"O que é base64?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Imagine que você quer inserir uma imagem em uma página web. Temos então um típico caso no qual a conversão para base64 é útil: páginas HTML são otimizadas para texto, e portanto converter as informações binárias para texto se torna interessante.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Como funciona a codificação?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Para simplificar, vamos utilizar o exemplo anterior.\\nA palavra \\\"Man\\\" é representada por 3 bytes, \", _jsx(_components.code, {\n          children: \"01001101\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01100001\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01101110\"\n        }), \".\\nCada byte possui 8 bits, porém para iniciar a codificação para base64, precisamos que cada caractere corresponda a 6 bits. \", _jsx(_components.em, {\n          children: \"(Detalhe: 2^6 é igual a 64, o número total de valores possíveis em base64, portanto o nome da codificação)\"\n        }), \"\\nIsso é feito juntando os 3 números, obtendo uma string de 24 bits: \", _jsx(_components.code, {\n          children: \"010011010110000101101110\"\n        }), \".\\nDividindo a string de 24 bits em 4 dígitos de 6 bits cada, temos agora:\\n\", _jsx(_components.code, {\n          children: \"010011\"\n        }), \" \", _jsx(_components.code, {\n          children: \"010110\"\n        }), \" \", _jsx(_components.code, {\n          children: \"000101\"\n        }), \" \", _jsx(_components.code, {\n          children: \"101110\"\n        }), \", que correspondem, em decimal, a \", _jsx(_components.code, {\n          children: \"19\"\n        }), \",\", _jsx(_components.code, {\n          children: \"22\"\n        }), \",\", _jsx(_components.code, {\n          children: \"5\"\n        }), \" e \", _jsx(_components.code, {\n          children: \"46\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"O próximo passo é encontrar a correspondência de cada dígito na tabela base64:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5i8q51ad7u1zer65zljs.png\",\n          alt: \"tabela base64\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Finalmente, isso nos dá \", _jsx(_components.code, {\n          children: \"TWFu\"\n        }), \" como resultado. A codificação está feita. :tada:\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"A divisão em 24 bits e padding\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Sabendo que a conversão para base64 se dá em grupos de 24 bits, ou de 4 dígitos com 6 bits, chegamos a uma questão importante: \", _jsx(_components.strong, {\n          children: \"o que ocorre caso não tenhamos os 4 dígitos completos?\"\n        }), \"\\nVamos supor que em vez de \\\"Man\\\", tenhamos \\\"Ma\\\". Isso resultaria em dois bytes, ou 16 bits no total.\\nO próximo múltiplo de 6 é 18, logo, para que possamos ter 3 dígitos de 6 bits, precisamos adicionar 2 bits na string representada.\\nIsso significa que \", _jsx(_components.code, {\n          children: \"0100110101100001\"\n        }), \" se torna \", _jsx(_components.code, {\n          children: \"010011010110000100\"\n        }), \", porque adicionamos 2 bits - dois zeros - no final, o que é chamado de \", _jsx(_components.em, {\n          children: \"padding\"\n        }), \". Assim, podemos então dividir essa string em 3 dígitos de 6 bits e adicionar um quarto bit para completar o quarteto. Esse bit é o padding que, na hora da conversão para ASCII, vai ser representado por \", _jsx(_components.code, {\n          children: \"=\"\n        }), \". Então Ma corresponde agora a \", _jsx(_components.code, {\n          children: \"TWE=\"\n        }), \".\\nVeja, no exemplo abaixo, alguns casos onde o padding é adicionado:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ayqxq04qgkve5wcq7xzi.png\",\n          alt: \"padding examples\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"É importante notar que nem sempre o padding vai ser obrigatório, já que é possível saber se há bits que faltam pelo tamanho da string codificada - já que esse número deve ser sempre múltiplo de 4.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"base64"},"buildId":"ecsgcraKaXzPxBFC2Ur8N","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>