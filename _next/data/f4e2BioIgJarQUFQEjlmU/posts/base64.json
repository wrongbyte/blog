{"pageProps":{"title":"Como funciona a codificação em base64?","description":"Entendendo o significado de letras e números aparentemente aleatórios","date":"Wed Feb 23 2022","content":"\nQuando falamos de texto - ou, mais precisamente, as letras que compõem o alfabeto - estamos falando de caracteres individuais que são representados da mesma forma que números, quando lidos pelo computador. Isto é, tanto letras e números são convertidos para **valores binários**.\n\nVeja a tabela abaixo:\n![tabela ascii](https://s2.glbimg.com/fEu3dqWDHAo0Gi1rGJin--DMiT4=/695x0/s.glbimg.com/po/tt2/f/original/2015/02/12/imagem28.jpg)\n\nCada letra possui um índice na chamada tabela ASCII. Isso significa que podemos representar letras através de números.\nLogo, a palavra \"Man\" seria representada pelos valores 77, 97 e 110. \nEsses valores, por sua vez, convertidos para base binária, correspondem a `01001101` `01100001` `01101110`.\nAté aqui, nenhuma informação muito nova. \n\nContudo, o que acontece se quisermos codificar dados binários e transmiti-los através de locais que são designados para lidar com dados em texto (caracteres alfanuméricos)? \nA forma escolhida para fazer isso de maneira otimizada é **codificar os dados na base64**.\n\n### O que é base64?\nImagine que você quer inserir uma imagem em uma página web. Temos então um típico caso no qual a conversão para base64 é útil: páginas HTML são otimizadas para texto, e portanto converter as informações binárias para texto se torna interessante.\n\n### Como funciona a codificação?\nPara simplificar, vamos utilizar o exemplo anterior.\nA palavra \"Man\" é representada por 3 bytes, `01001101` `01100001` `01101110`. \nCada byte possui 8 bits, porém para iniciar a codificação para base64, precisamos que cada caractere corresponda a 6 bits. _(Detalhe: 2^6 é igual a 64, o número total de valores possíveis em base64, portanto o nome da codificação)_\nIsso é feito juntando os 3 números, obtendo uma string de 24 bits: `010011010110000101101110`.\nDividindo a string de 24 bits em 4 dígitos de 6 bits cada, temos agora:\n`010011` `010110` `000101` `101110`, que correspondem, em decimal, a `19`,`22`,`5` e `46`.\n\nO próximo passo é encontrar a correspondência de cada dígito na tabela base64:\n![tabela base64](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5i8q51ad7u1zer65zljs.png)\n\nFinalmente, isso nos dá `TWFu` como resultado. A codificação está feita. :tada:\n\n\n#### A divisão em 24 bits e padding\nSabendo que a conversão para base64 se dá em grupos de 24 bits, ou de 4 dígitos com 6 bits, chegamos a uma questão importante: **o que ocorre caso não tenhamos os 4 dígitos completos?**\nVamos supor que em vez de \"Man\", tenhamos \"Ma\". Isso resultaria em dois bytes, ou 16 bits no total.\nO próximo múltiplo de 6 é 18, logo, para que possamos ter 3 dígitos de 6 bits, precisamos adicionar 2 bits na string representada.\nIsso significa que `0100110101100001` se torna `010011010110000100`, porque adicionamos 2 bits - dois zeros - no final, o que é chamado de _padding_. Assim, podemos então dividir essa string em 3 dígitos de 6 bits e adicionar um quarto bit para completar o quarteto. Esse bit é o padding que, na hora da conversão para ASCII, vai ser representado por `=`. Então Ma corresponde agora a `TWE=`.\nVeja, no exemplo abaixo, alguns casos onde o padding é adicionado:\n![padding examples](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ayqxq04qgkve5wcq7xzi.png)\n \nÉ importante notar que nem sempre o padding vai ser obrigatório, já que é possível saber se há bits que faltam pelo tamanho da string codificada - já que esse número deve ser sempre múltiplo de 4.","slug":"base64","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      strong: \"strong\",\n      img: \"img\",\n      code: \"code\",\n      h3: \"h3\",\n      em: \"em\",\n      h4: \"h4\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"Quando falamos de texto - ou, mais precisamente, as letras que compõem o alfabeto - estamos falando de caracteres individuais que são representados da mesma forma que números, quando lidos pelo computador. Isto é, tanto letras e números são convertidos para \", _jsx(_components.strong, {\n          children: \"valores binários\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Veja a tabela abaixo:\\n\", _jsx(_components.img, {\n          src: \"https://s2.glbimg.com/fEu3dqWDHAo0Gi1rGJin--DMiT4=/695x0/s.glbimg.com/po/tt2/f/original/2015/02/12/imagem28.jpg\",\n          alt: \"tabela ascii\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Cada letra possui um índice na chamada tabela ASCII. Isso significa que podemos representar letras através de números.\\nLogo, a palavra \\\"Man\\\" seria representada pelos valores 77, 97 e 110.\\nEsses valores, por sua vez, convertidos para base binária, correspondem a \", _jsx(_components.code, {\n          children: \"01001101\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01100001\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01101110\"\n        }), \".\\nAté aqui, nenhuma informação muito nova.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Contudo, o que acontece se quisermos codificar dados binários e transmiti-los através de locais que são designados para lidar com dados em texto (caracteres alfanuméricos)?\\nA forma escolhida para fazer isso de maneira otimizada é \", _jsx(_components.strong, {\n          children: \"codificar os dados na base64\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"O que é base64?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Imagine que você quer inserir uma imagem em uma página web. Temos então um típico caso no qual a conversão para base64 é útil: páginas HTML são otimizadas para texto, e portanto converter as informações binárias para texto se torna interessante.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Como funciona a codificação?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Para simplificar, vamos utilizar o exemplo anterior.\\nA palavra \\\"Man\\\" é representada por 3 bytes, \", _jsx(_components.code, {\n          children: \"01001101\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01100001\"\n        }), \" \", _jsx(_components.code, {\n          children: \"01101110\"\n        }), \".\\nCada byte possui 8 bits, porém para iniciar a codificação para base64, precisamos que cada caractere corresponda a 6 bits. \", _jsx(_components.em, {\n          children: \"(Detalhe: 2^6 é igual a 64, o número total de valores possíveis em base64, portanto o nome da codificação)\"\n        }), \"\\nIsso é feito juntando os 3 números, obtendo uma string de 24 bits: \", _jsx(_components.code, {\n          children: \"010011010110000101101110\"\n        }), \".\\nDividindo a string de 24 bits em 4 dígitos de 6 bits cada, temos agora:\\n\", _jsx(_components.code, {\n          children: \"010011\"\n        }), \" \", _jsx(_components.code, {\n          children: \"010110\"\n        }), \" \", _jsx(_components.code, {\n          children: \"000101\"\n        }), \" \", _jsx(_components.code, {\n          children: \"101110\"\n        }), \", que correspondem, em decimal, a \", _jsx(_components.code, {\n          children: \"19\"\n        }), \",\", _jsx(_components.code, {\n          children: \"22\"\n        }), \",\", _jsx(_components.code, {\n          children: \"5\"\n        }), \" e \", _jsx(_components.code, {\n          children: \"46\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"O próximo passo é encontrar a correspondência de cada dígito na tabela base64:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5i8q51ad7u1zer65zljs.png\",\n          alt: \"tabela base64\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Finalmente, isso nos dá \", _jsx(_components.code, {\n          children: \"TWFu\"\n        }), \" como resultado. A codificação está feita. :tada:\"]\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"A divisão em 24 bits e padding\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Sabendo que a conversão para base64 se dá em grupos de 24 bits, ou de 4 dígitos com 6 bits, chegamos a uma questão importante: \", _jsx(_components.strong, {\n          children: \"o que ocorre caso não tenhamos os 4 dígitos completos?\"\n        }), \"\\nVamos supor que em vez de \\\"Man\\\", tenhamos \\\"Ma\\\". Isso resultaria em dois bytes, ou 16 bits no total.\\nO próximo múltiplo de 6 é 18, logo, para que possamos ter 3 dígitos de 6 bits, precisamos adicionar 2 bits na string representada.\\nIsso significa que \", _jsx(_components.code, {\n          children: \"0100110101100001\"\n        }), \" se torna \", _jsx(_components.code, {\n          children: \"010011010110000100\"\n        }), \", porque adicionamos 2 bits - dois zeros - no final, o que é chamado de \", _jsx(_components.em, {\n          children: \"padding\"\n        }), \". Assim, podemos então dividir essa string em 3 dígitos de 6 bits e adicionar um quarto bit para completar o quarteto. Esse bit é o padding que, na hora da conversão para ASCII, vai ser representado por \", _jsx(_components.code, {\n          children: \"=\"\n        }), \". Então Ma corresponde agora a \", _jsx(_components.code, {\n          children: \"TWE=\"\n        }), \".\\nVeja, no exemplo abaixo, alguns casos onde o padding é adicionado:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ayqxq04qgkve5wcq7xzi.png\",\n          alt: \"padding examples\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"É importante notar que nem sempre o padding vai ser obrigatório, já que é possível saber se há bits que faltam pelo tamanho da string codificada - já que esse número deve ser sempre múltiplo de 4.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}