{"pageProps":{"title":"Como funciona o encoding no protocolo HTTP?","description":"Ou: o que acontece com os bytes das requisições HTTP quando você se comunica com alguns servidores?","date":"Thu Jan 20 2022","content":"\n### Antes, um pouco de contexto...\nQuando temos um arquivo grande e precisamos mandá-lo para alguém, o que vem na nossa cabeça de imediato é _“zipar”_ este arquivo.\n\nQuando _zipamos_, isto é, comprimimos um arquivo, o que estamos fazendo na realidade ~~(de forma simplificada, é claro)~~ é aplicar um **algoritmo de compressão** nos seus bytes. O que esses algoritmos fazem é diminuir a redundância da sequência de bytes que compõe o arquivo, utilizando de referências como ponteiros onde ocorrem sequências que já se repetem. \n\n\n### Mas qual a relação entre esses algoritmos e o protocolo HTTP?\nImagine que você deseja fazer um GET request para um site, por exemplo para http://example.org.\nNo seu browser, você vai ver a seguinte página, interpretada pelo seu browser:\n![Site normal](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gt3t8q20lvryghcx62m8.png)\n \nContudo, o que você de fato recebe do servidor é uma **enorme stream contendo o código-fonte da página**, após as headers:\n![Código fonte do site](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wtq2n6c7nngf6taw83ho.png)\n\nLogo transferir o conteúdo de páginas contendo uma quantidade extensa de dados torna-se pouco efetivo, tanto para o cliente quanto para o servidor. **A partir disso, podemos então \"zipar\" a resposta que recebemos. Ao fazer isso, diminuímos o tamanho da resposta, que vem comprimida, e assim aumentamos a eficiência da comunicação.**\n\n\n\n### Como isso ocorre?\nNormalmente, a resposta é comprimida utilizando-se do algoritmo **gzip**, mas isso vai depender do servidor. \nAntes da aplicação efetiva do algoritmo de compressão, ocorre a chamada \"negociação\" entre o browser e o servidor: **o browser envia a header `accept-encoding`** com o algoritmo suportado (exemplo: `Accept-Encoding: gzip`) e **o server responde com a header `content-encoding`** com o algoritmo escolhido.\n![Negociação HTTTP](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/b3zumzo1mutvmyh6z7sp.png)\nObs: nesse caso, usamos a header `Vary` para armazenar em cache os diferentes valores para o encoding.\n\nDessa forma, as headers `Accept-Encoding` e `Content-Encoding` vão definir o algoritmo de compressão escolhido para diminuir o tamanho dos arquivos sendo transferidos na comunicação. Isso é de extrema importância para tornar o uso da conexão mais eficiente.\n\n\n### Mas é possível otimizar ainda mais a comunicação através do uso de outra header: `Transfer-Encoding` \nQuando recebemos a resposta do servidor, recebemos o que é chamado de \"payload\". Isso é a resposta que pode ser, como já vimos acima, uma página HTML por exemplo.\n![payload](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x2yrsfwc86m5l6aauyqz.png)\n\n> _Definition of payload : The \"actual data\" in a packet or file minus all headers attached for transport and minus all descriptive meta-data. In a network packet, headers are appended to the payload for transport and then discarded at their destination._\n\n**Contudo, é possível \"dividir\" esse payload, e isso ocorre quando utilizamos da header `transfer-encoding`.** Quando essa header não é utilizada, o payload body e message body são iguais.\n \nExemplo da resposta vista antes, porém com transfer-encoding:\n![chunked response](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bl300b8gih3mv37xjilu.png)\n\nOu seja, as respostas com transfer-encoding seguem a seguinte estrutura:\n![estrutura](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7pc1mu71szfb49yb5q9i.png)\nIsso divide as informações recebidas em **chunks**, ou seja, \"pedaços\" de dados. Isso, além de ajudar a diminuir a carga da comunicação, ajuda o servidor a manter uma conexão mesmo para conteúdos gerados dinamicamente.\nEm muitos servidores, é comum ocorrer a combinação de Content-Encoding: gzip + Transfer-Encoding: chunked, por tornarem a comunicação mais eficiente.\n ","slug":"httpencoding","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h3: \"h3\",\n      p: \"p\",\n      em: \"em\",\n      strong: \"strong\",\n      img: \"img\",\n      code: \"code\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h3, {\n        children: \"Antes, um pouco de contexto...\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Quando temos um arquivo grande e precisamos mandá-lo para alguém, o que vem na nossa cabeça de imediato é \", _jsx(_components.em, {\n          children: \"“zipar”\"\n        }), \" este arquivo.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Quando \", _jsx(_components.em, {\n          children: \"zipamos\"\n        }), \", isto é, comprimimos um arquivo, o que estamos fazendo na realidade ~~(de forma simplificada, é claro)~~ é aplicar um \", _jsx(_components.strong, {\n          children: \"algoritmo de compressão\"\n        }), \" nos seus bytes. O que esses algoritmos fazem é diminuir a redundância da sequência de bytes que compõe o arquivo, utilizando de referências como ponteiros onde ocorrem sequências que já se repetem.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Mas qual a relação entre esses algoritmos e o protocolo HTTP?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Imagine que você deseja fazer um GET request para um site, por exemplo para http://example.org.\\nNo seu browser, você vai ver a seguinte página, interpretada pelo seu browser:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gt3t8q20lvryghcx62m8.png\",\n          alt: \"Site normal\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Contudo, o que você de fato recebe do servidor é uma \", _jsx(_components.strong, {\n          children: \"enorme stream contendo o código-fonte da página\"\n        }), \", após as headers:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wtq2n6c7nngf6taw83ho.png\",\n          alt: \"Código fonte do site\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Logo transferir o conteúdo de páginas contendo uma quantidade extensa de dados torna-se pouco efetivo, tanto para o cliente quanto para o servidor. \", _jsx(_components.strong, {\n          children: \"A partir disso, podemos então \\\"zipar\\\" a resposta que recebemos. Ao fazer isso, diminuímos o tamanho da resposta, que vem comprimida, e assim aumentamos a eficiência da comunicação.\"\n        })]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Como isso ocorre?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Normalmente, a resposta é comprimida utilizando-se do algoritmo \", _jsx(_components.strong, {\n          children: \"gzip\"\n        }), \", mas isso vai depender do servidor.\\nAntes da aplicação efetiva do algoritmo de compressão, ocorre a chamada \\\"negociação\\\" entre o browser e o servidor: \", _jsxs(_components.strong, {\n          children: [\"o browser envia a header \", _jsx(_components.code, {\n            children: \"accept-encoding\"\n          })]\n        }), \" com o algoritmo suportado (exemplo: \", _jsx(_components.code, {\n          children: \"Accept-Encoding: gzip\"\n        }), \") e \", _jsxs(_components.strong, {\n          children: [\"o server responde com a header \", _jsx(_components.code, {\n            children: \"content-encoding\"\n          })]\n        }), \" com o algoritmo escolhido.\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/b3zumzo1mutvmyh6z7sp.png\",\n          alt: \"Negociação HTTTP\"\n        }), \"\\nObs: nesse caso, usamos a header \", _jsx(_components.code, {\n          children: \"Vary\"\n        }), \" para armazenar em cache os diferentes valores para o encoding.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Dessa forma, as headers \", _jsx(_components.code, {\n          children: \"Accept-Encoding\"\n        }), \" e \", _jsx(_components.code, {\n          children: \"Content-Encoding\"\n        }), \" vão definir o algoritmo de compressão escolhido para diminuir o tamanho dos arquivos sendo transferidos na comunicação. Isso é de extrema importância para tornar o uso da conexão mais eficiente.\"]\n      }), \"\\n\", _jsxs(_components.h3, {\n        children: [\"Mas é possível otimizar ainda mais a comunicação através do uso de outra header: \", _jsx(_components.code, {\n          children: \"Transfer-Encoding\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Quando recebemos a resposta do servidor, recebemos o que é chamado de \\\"payload\\\". Isso é a resposta que pode ser, como já vimos acima, uma página HTML por exemplo.\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x2yrsfwc86m5l6aauyqz.png\",\n          alt: \"payload\"\n        })]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.em, {\n            children: \"Definition of payload : The \\\"actual data\\\" in a packet or file minus all headers attached for transport and minus all descriptive meta-data. In a network packet, headers are appended to the payload for transport and then discarded at their destination.\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsxs(_components.strong, {\n          children: [\"Contudo, é possível \\\"dividir\\\" esse payload, e isso ocorre quando utilizamos da header \", _jsx(_components.code, {\n            children: \"transfer-encoding\"\n          }), \".\"]\n        }), \" Quando essa header não é utilizada, o payload body e message body são iguais.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Exemplo da resposta vista antes, porém com transfer-encoding:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bl300b8gih3mv37xjilu.png\",\n          alt: \"chunked response\"\n        })]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Ou seja, as respostas com transfer-encoding seguem a seguinte estrutura:\\n\", _jsx(_components.img, {\n          src: \"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7pc1mu71szfb49yb5q9i.png\",\n          alt: \"estrutura\"\n        }), \"\\nIsso divide as informações recebidas em \", _jsx(_components.strong, {\n          children: \"chunks\"\n        }), \", ou seja, \\\"pedaços\\\" de dados. Isso, além de ajudar a diminuir a carga da comunicação, ajuda o servidor a manter uma conexão mesmo para conteúdos gerados dinamicamente.\\nEm muitos servidores, é comum ocorrer a combinação de Content-Encoding: gzip + Transfer-Encoding: chunked, por tornarem a comunicação mais eficiente.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}