{"pageProps":{"title":"What are closures?","description":"Let's dive deep into scopes, lifetimes, variables and functions","date":"Thu Sep 29 2022","content":"\nThe concept of _closure_ is important when it comes to understanding how languages such as Javascript work - and how scopes, lifetimes and references come together and can be combined to provide useful features to programmers.\n\n## Variables and their scopes\n### 1 - Local and global scope\nEvery time you use a variable inside a function, this variable needs to be declared somewhere - and this place can be the **local scope** (inside of the function) or the **global scope**.\nVariables declared in the local scope are only accessible inside of their parent function - which means you cannot reference them outside of the function:\n```javascript\nfunction() {\n  let a = 1;\n  console.log(a); // works\n}    \nconsole.log(a); // fails\n```\nIn the example above, written in JS, we get an `Uncaught ReferenceError: a is not defined`.\n\nHowever, by declaring `a` as a global variable, we can reference it anywhere in our code:\n```js\nvar a = 1;\nfunction() {\n  console.log(a); // works\n}    \nconsole.log(a); // works\n```\n\n### 2 - Lifetime of entities\nThe behavior above happens because entities (variables, constants, etc) have different **lifetimes** across a program depending on their **scope**. The definition of the \"lifetime\" of an entity can be thought as the period from its creation (allocating memory for it) to its destruction (deallocating the memory used for this variable).\n\nA **global variable has the same lifetime of the entire program**. **Local variables**, however, **have specific lifetimes**, so they may not be \"alive\" during the entire programâ€™s lifecycle. \nHence, the underlying programming language must provide a way to deal which such cases, such as manual memory management or some kind of garbage collector. Otherwise, one could stumble upon a _dangling reference_ when not careful enough, since deallocated variables cannot be referenced.\n\nThis dynamic is important to understand because we'll eventually get into a tricky question:\n\n_What would happen if we wanted to reference a variable outside of its original scope?_\n\n### 3 - Nested functions\nThere is a special use case of functions in which we face the question above.\nLet's say we wanted to create a function inside of another function. Let's call them `outer` and `inner`.\n\n```js\nconst outer = function() {\n  const inner = function() {\n     console.log(\"hello\");\n  }\n}\n```\n\nEverything declared inside of `inner` has now access to the scope of `outer`. \nIt means that we can declare variables inside of `outer` and then use them inside of `inner`, as it follows:\n\n\n```js\nconst outer = function() {\n  const a = 1;\n  const inner = function() {\n    console.log(a);\n  }\n  return inner;\n}\n\nvar fnc = outer(); // execute outer to get inner \nfnc();\n\n```\n\nWe can then return `inner` from `outer`. This part is important because it permits `inner` to leave the scope of `outer`.\nAfter that, we assign the return of outer to a variable `fnc`, which we can execute to get `inner`.\n\nTherefore, we now have all variables of `inner`, declared in `outer`, _closed_ under this function. \n\n**What we'll seeing here is basically the implementation of _closures_ in Javascript: a function that has access to the additional data from its surrounding scope.**\n\nTherefore, we can define a closure as:\n```\n1 - A function and\n2 - A reference to that function's outer scope\n```\n\nIn the example above, our <u>function</u> is `inner` and the <u>outer scope</u> is the scope of `outer`, which has the variable `a`. Without keeping a reference to this surrounding scope, we would not be able to retrieve the value of `a`. Once we have a reference to this surrounding scope, we have a closure.\n\n### Back to scope and lifetimes: what would happen if we didn't have closures?\nThere are languages that don't implement closures. \nC is a good example: in C, you won't have closures as well as native support for nested functions. \nUsing the simplified definition we've seen before, we can say that what's needed to implement closures is a record of the function along with its environment. \nTo do this in C, there would be necessary to use structs, function pointers and a lot of fuzzy code. Furthermore, it would be necessary to have support for nested functions, which C doesn't have by default. Since closures are only meaningful when a function needs to be executed outside of the scope in which it was originally declared, having nested functions is essential for this concept to work.\nA lot of work, huh?\n\n### How Javascript solves it?\nWe already learned that JS implements closures and what they are. But how does it work under the hood?\n\nEvery function in JavaScript maintains a reference to its outer environment. This reference is used to determine the execution context of the function when it is invoked, and therefore enables the function to \"see\" variables declared outside of it.\nIt creates a kind of _state_ particular to the functions declared in the same _lexical environment_.\nIn addition, if we have functions that call other functions that in turn call even more functions, JS creates a chain of references to the outer lexical environments - which is called the _scope chain._ Therefore, closures in Javascript can become quite useful - and we are going to see a few uses for them now.\n\n## Why are closures useful?\n\nIf you have ever programmed using an object-oriented language, you will probably know the concept of classes and states.\nOnce you use a closure, you are creating the equivalent of a private state associated with a function.\n```js\nfunction foo() {\n  const secret = Math.trunc(Math.random() * 100)\n  return function inner() {\n    console.log(`The secret number is ${secret}.`)\n  }\n}\nconst f = foo() // \nf()\n```\n\nIn the example above, `secret` is not directly accessible from outside `foo`. `foo` then creates a kind of encapsulation similar to what we see in OOP, which is useful in several cases. Furthermore, JavaScript did not have a class syntax until 2015 - making the use of closures an alternative.\n\nFinally, there are several other use cases for closures - such as _currying_, in functional programming, event-oriented programming and so on.\n\n> ðŸ’¡ Further reading: [Nested functions, closures and first-class functions](https://gist.github.com/wrongbyte/3b5f0b09706d818e24c5b18c4b2639cb)","slug":"closures","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      em: \"em\",\n      h2: \"h2\",\n      h3: \"h3\",\n      strong: \"strong\",\n      pre: \"pre\",\n      code: \"code\",\n      blockquote: \"blockquote\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"The concept of \", _jsx(_components.em, {\n          children: \"closure\"\n        }), \" is important when it comes to understanding how languages such as Javascript work - and how scopes, lifetimes and references come together and can be combined to provide useful features to programmers.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Variables and their scopes\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"1 - Local and global scope\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Every time you use a variable inside a function, this variable needs to be declared somewhere - and this place can be the \", _jsx(_components.strong, {\n          children: \"local scope\"\n        }), \" (inside of the function) or the \", _jsx(_components.strong, {\n          children: \"global scope\"\n        }), \".\\nVariables declared in the local scope are only accessible inside of their parent function - which means you cannot reference them outside of the function:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-javascript\",\n          children: \"function() {\\n  let a = 1;\\n  console.log(a); // works\\n}    \\nconsole.log(a); // fails\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In the example above, written in JS, we get an \", _jsx(_components.code, {\n          children: \"Uncaught ReferenceError: a is not defined\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, by declaring \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" as a global variable, we can reference it anywhere in our code:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"var a = 1;\\nfunction() {\\n  console.log(a); // works\\n}    \\nconsole.log(a); // works\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"2 - Lifetime of entities\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The behavior above happens because entities (variables, constants, etc) have different \", _jsx(_components.strong, {\n          children: \"lifetimes\"\n        }), \" across a program depending on their \", _jsx(_components.strong, {\n          children: \"scope\"\n        }), \". The definition of the \\\"lifetime\\\" of an entity can be thought as the period from its creation (allocating memory for it) to its destruction (deallocating the memory used for this variable).\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"global variable has the same lifetime of the entire program\"\n        }), \". \", _jsx(_components.strong, {\n          children: \"Local variables\"\n        }), \", however, \", _jsx(_components.strong, {\n          children: \"have specific lifetimes\"\n        }), \", so they may not be \\\"alive\\\" during the entire programâ€™s lifecycle.\\nHence, the underlying programming language must provide a way to deal which such cases, such as manual memory management or some kind of garbage collector. Otherwise, one could stumble upon a \", _jsx(_components.em, {\n          children: \"dangling reference\"\n        }), \" when not careful enough, since deallocated variables cannot be referenced.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This dynamic is important to understand because we'll eventually get into a tricky question:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"What would happen if we wanted to reference a variable outside of its original scope?\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"3 - Nested functions\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"There is a special use case of functions in which we face the question above.\\nLet's say we wanted to create a function inside of another function. Let's call them \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"const outer = function() {\\n  const inner = function() {\\n     console.log(\\\"hello\\\");\\n  }\\n}\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Everything declared inside of \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" has now access to the scope of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \".\\nIt means that we can declare variables inside of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \" and then use them inside of \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \", as it follows:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"const outer = function() {\\n  const a = 1;\\n  const inner = function() {\\n    console.log(a);\\n  }\\n  return inner;\\n}\\n\\nvar fnc = outer(); // execute outer to get inner \\nfnc();\\n\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We can then return \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" from \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \". This part is important because it permits \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" to leave the scope of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \".\\nAfter that, we assign the return of outer to a variable \", _jsx(_components.code, {\n          children: \"fnc\"\n        }), \", which we can execute to get \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Therefore, we now have all variables of \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \", declared in \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \", \", _jsx(_components.em, {\n          children: \"closed\"\n        }), \" under this function.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsxs(_components.strong, {\n          children: [\"What we'll seeing here is basically the implementation of \", _jsx(_components.em, {\n            children: \"closures\"\n          }), \" in Javascript: a function that has access to the additional data from its surrounding scope.\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Therefore, we can define a closure as:\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          children: \"1 - A function and\\n2 - A reference to that function's outer scope\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In the example above, our \", _jsx(\"u\", {\n          children: \"function\"\n        }), \" is \", _jsx(_components.code, {\n          children: \"inner\"\n        }), \" and the \", _jsx(\"u\", {\n          children: \"outer scope\"\n        }), \" is the scope of \", _jsx(_components.code, {\n          children: \"outer\"\n        }), \", which has the variable \", _jsx(_components.code, {\n          children: \"a\"\n        }), \". Without keeping a reference to this surrounding scope, we would not be able to retrieve the value of \", _jsx(_components.code, {\n          children: \"a\"\n        }), \". Once we have a reference to this surrounding scope, we have a closure.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Back to scope and lifetimes: what would happen if we didn't have closures?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are languages that don't implement closures.\\nC is a good example: in C, you won't have closures as well as native support for nested functions.\\nUsing the simplified definition we've seen before, we can say that what's needed to implement closures is a record of the function along with its environment.\\nTo do this in C, there would be necessary to use structs, function pointers and a lot of fuzzy code. Furthermore, it would be necessary to have support for nested functions, which C doesn't have by default. Since closures are only meaningful when a function needs to be executed outside of the scope in which it was originally declared, having nested functions is essential for this concept to work.\\nA lot of work, huh?\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"How Javascript solves it?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We already learned that JS implements closures and what they are. But how does it work under the hood?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Every function in JavaScript maintains a reference to its outer environment. This reference is used to determine the execution context of the function when it is invoked, and therefore enables the function to \\\"see\\\" variables declared outside of it.\\nIt creates a kind of \", _jsx(_components.em, {\n          children: \"state\"\n        }), \" particular to the functions declared in the same \", _jsx(_components.em, {\n          children: \"lexical environment\"\n        }), \".\\nIn addition, if we have functions that call other functions that in turn call even more functions, JS creates a chain of references to the outer lexical environments - which is called the \", _jsx(_components.em, {\n          children: \"scope chain.\"\n        }), \" Therefore, closures in Javascript can become quite useful - and we are going to see a few uses for them now.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Why are closures useful?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"If you have ever programmed using an object-oriented language, you will probably know the concept of classes and states.\\nOnce you use a closure, you are creating the equivalent of a private state associated with a function.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-js\",\n          children: \"function foo() {\\n  const secret = Math.trunc(Math.random() * 100)\\n  return function inner() {\\n    console.log(`The secret number is ${secret}.`)\\n  }\\n}\\nconst f = foo() // \\nf()\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In the example above, \", _jsx(_components.code, {\n          children: \"secret\"\n        }), \" is not directly accessible from outside \", _jsx(_components.code, {\n          children: \"foo\"\n        }), \". \", _jsx(_components.code, {\n          children: \"foo\"\n        }), \" then creates a kind of encapsulation similar to what we see in OOP, which is useful in several cases. Furthermore, JavaScript did not have a class syntax until 2015 - making the use of closures an alternative.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Finally, there are several other use cases for closures - such as \", _jsx(_components.em, {\n          children: \"currying\"\n        }), \", in functional programming, event-oriented programming and so on.\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"ðŸ’¡ Further reading: \", _jsx(_components.a, {\n            href: \"https://gist.github.com/wrongbyte/3b5f0b09706d818e24c5b18c4b2639cb\",\n            children: \"Nested functions, closures and first-class functions\"\n          })]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}