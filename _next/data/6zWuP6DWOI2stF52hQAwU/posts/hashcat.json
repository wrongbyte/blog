{"pageProps":{"title":"Cracking a hashed password with hashcat","description":"... through a simple example of how this process works","date":"Thu Jun 16 2022","content":"\nGiven a hashed password `$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom`, we have only one hint: **the password has four letters, all lowercase.**\n\n### Let's start: finding the hash type\nThere are **a lot** of hashes out there. A good way to start guessing is to look at the hashed pass and try to find some kind of pattern. Here, the key is the first 4 characters of the hash.\nThere is a page where you can look at example hashes: https://hashcat.net/wiki/doku.php?id=example_hashes\n**Noticed something?** We are looking for the _bcrypt $2*$, Blowfish (Unix)_. Our `$2y$` matches this pattern. So we are looking for a bcrypt hash. We also can grasp that the hash was generated using a factor of 12 (it is the number that comes after the first four characters).\n\n### Let's crack!\nFirst, it is important to know how the process works. Hashing is a process essentially different from encryption - you can only do it once. It means that we cannot _really_ recover the plaintext of a hashed password; instead, we can only compare its hash with our guesses. So, it's like hashing several words and seeing which of them matches exaclty our hash. Then, it must be the password.\nWe can automatize this process with two tools: `hashcat` and a dictionary of potential passwords. This kind of dictionary is easy to find on internet, so we are going to use [rock you](https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt).\n\nOk, so our dictionary is _very large_ and checking for each password, one by one, would be an expensive operation. But we already know how our password looks like, right? (four letters, all lowercase).\nSo, let's filter our dictionary a little bit by creating a file containing all the passwords that match our condition: \n\n`grep -x -E '[a-z][^0-9]{4}' rockyou.txt > candidates.txt`\n\nHere we are using `grep` along with a regex expression to filter our potential passwords to only four-letters words without digits. The -x flag applies this expression to the whole line (our file contains one password per line), whereas the -E flag is needed because we are using an extended expression (due to the `{4}` part).\n\nNow, we are ready to crack it with hashcat:\n\n`hashcat -a 0 -m 3200 pass.txt candidates.txt --force`\n\nHere, the code 3200 stands for the `bcrypt` hash, and our hashed pass is stored in pass.txt whereas the potential passwords are stored in candidates.txt.\n\nAfter a few seconds (depending on your computer), we have the result:\n`$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom:bleh`\n\nWhere the \"bleh\" is the password we were looking for.\n\n~~_In sum: use a password manager :)_~~\n","slug":"hashcat","source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      code: \"code\",\n      strong: \"strong\",\n      h3: \"h3\",\n      em: \"em\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.p, {\n        children: [\"Given a hashed password \", _jsx(_components.code, {\n          children: \"$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom\"\n        }), \", we have only one hint: \", _jsx(_components.strong, {\n          children: \"the password has four letters, all lowercase.\"\n        })]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Let's start: finding the hash type\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"There are \", _jsx(_components.strong, {\n          children: \"a lot\"\n        }), \" of hashes out there. A good way to start guessing is to look at the hashed pass and try to find some kind of pattern. Here, the key is the first 4 characters of the hash.\\nThere is a page where you can look at example hashes: https://hashcat.net/wiki/doku.php?id=example_hashes\\n\", _jsx(_components.strong, {\n          children: \"Noticed something?\"\n        }), \" We are looking for the \", _jsx(_components.em, {\n          children: \"bcrypt $2*$, Blowfish (Unix)\"\n        }), \". Our \", _jsx(_components.code, {\n          children: \"$2y$\"\n        }), \" matches this pattern. So we are looking for a bcrypt hash. We also can grasp that the hash was generated using a factor of 12 (it is the number that comes after the first four characters).\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Let's crack!\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"First, it is important to know how the process works. Hashing is a process essentially different from encryption - you can only do it once. It means that we cannot \", _jsx(_components.em, {\n          children: \"really\"\n        }), \" recover the plaintext of a hashed password; instead, we can only compare its hash with our guesses. So, it's like hashing several words and seeing which of them matches exaclty our hash. Then, it must be the password.\\nWe can automatize this process with two tools: \", _jsx(_components.code, {\n          children: \"hashcat\"\n        }), \" and a dictionary of potential passwords. This kind of dictionary is easy to find on internet, so we are going to use \", _jsx(_components.a, {\n          href: \"https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt\",\n          children: \"rock you\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Ok, so our dictionary is \", _jsx(_components.em, {\n          children: \"very large\"\n        }), \" and checking for each password, one by one, would be an expensive operation. But we already know how our password looks like, right? (four letters, all lowercase).\\nSo, let's filter our dictionary a little bit by creating a file containing all the passwords that match our condition:\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"grep -x -E '[a-z][^0-9]{4}' rockyou.txt > candidates.txt\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Here we are using \", _jsx(_components.code, {\n          children: \"grep\"\n        }), \" along with a regex expression to filter our potential passwords to only four-letters words without digits. The -x flag applies this expression to the whole line (our file contains one password per line), whereas the -E flag is needed because we are using an extended expression (due to the \", _jsx(_components.code, {\n          children: \"{4}\"\n        }), \" part).\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now, we are ready to crack it with hashcat:\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"hashcat -a 0 -m 3200 pass.txt candidates.txt --force\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Here, the code 3200 stands for the \", _jsx(_components.code, {\n          children: \"bcrypt\"\n        }), \" hash, and our hashed pass is stored in pass.txt whereas the potential passwords are stored in candidates.txt.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"After a few seconds (depending on your computer), we have the result:\\n\", _jsx(_components.code, {\n          children: \"$2y$12$Dwt1BZj6pcyc3Dy1FWZ5ieeUznr71EeNkJkUlypTsgbX1H68wsRom:bleh\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Where the \\\"bleh\\\" is the password we were looking for.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"~~\", _jsx(_components.em, {\n          children: \"In sum: use a password manager :)\"\n        }), \"~~\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}